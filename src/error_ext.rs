use Fail;
use std::error::Error;
use std::fmt::{self, Debug, Display};
use std::sync::Mutex;

/// Wrapper for std errors to make them Sync.
///
/// This exists to coerce existing types that are only `Error + Send + 'static`
/// into a `Fail`-compatible representation.
///
/// Unfortunately, this requires wrapping the error in a `Mutex`, which must be
/// locked for every `Debug`/`Display`.
pub struct SyncErr<T>(Mutex<T>);

impl<E> SyncErr<E> {
    fn new(err: E) -> Self {
        SyncErr(Mutex::new(err))
    }
}

impl<T> Display for SyncErr<T>
where
    T: Display,
{
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        self.0.lock().unwrap().fmt(f)
    }
}

impl<T> Debug for SyncErr<T>
where
    T: Debug,
{
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        self.0.lock().unwrap().fmt(f)
    }
}

impl<E: Display + Debug + Send + 'static> Fail for SyncErr<E> {}

/// Extensions for std errors
pub trait ErrorExt: Sized {
    /// Wrap a non-`Sync` `Error` in order to make it implement `Fail`.
    ///
    /// This exists to coerce existing types that are only `Error + Send +
    /// 'static` into a `Fail`-compatible representation, most notably for
    /// types generated by `error-chain`.
    ///
    /// Unfortunately, this requires wrapping the error in a `Mutex`, which must
    /// be locked for every `Debug`/`Display`. Therefore, this should be
    /// something of a last resort in making the error work with `failure`.
    ///
    /// # Example
    ///
    /// ```rust
    /// extern crate failure;
    ///
    /// # use std::error::Error as StdError;
    /// # use std::fmt::{self, Display};
    /// use failure::{Error, ErrorExt};
    /// use std::cell::RefCell;
    ///
    /// #[derive(Debug)]
    /// struct NonSyncError {
    ///     // RefCells are non-Sync, so structs containing them will be
    ///     // non-Sync as well.
    ///     count: RefCell<usize>,
    /// }
    ///
    /// // implement Display/Error for NonSyncError...
    /// #
    /// # impl StdError for NonSyncError {
    /// #     fn description(&self) -> &str {
    /// #         "oops!"
    /// #     }
    /// # }
    /// #
    /// # impl Display for NonSyncError {
    /// #     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
    /// #         write!(f, "oops!")
    /// #     }
    /// # }
    ///
    /// fn returns_error() -> Result<(), NonSyncError> {
    ///     // Do stuff
    ///     # Ok(())
    /// }
    ///
    /// fn my_function() -> Result<(), Error> {
    ///     // without the map_err here, we end up with a compile error
    ///     // complaining that NonSyncError doesn't implement Sync.
    ///     returns_error().map_err(ErrorExt::sync)?;
    ///     // Do more stuff
    ///     # Ok(())
    /// }
    /// #
    /// # fn main() {
    /// #    my_function().unwrap();
    /// # }
    /// ```
    ///
    fn sync(self) -> SyncErr<Self> {
        SyncErr::new(self)
    }
}

impl<E: Error + Send + 'static> ErrorExt for E {}
